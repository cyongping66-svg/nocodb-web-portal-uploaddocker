# 變更記錄

## 20231129 15:00 高級選項關聯字段功能優化
- **功能需求**：
  1. 允許同時勾選關聯字段功能和字典子表功能，實現更靈活的數據關係配置
  2. 剔除勾選關聯字段功能後出現的關聯類型選擇，簡化用戶界面
- **具體實現**：
  1. 移除了新增列對話框中的關聯類型選擇界面元素
  2. 移除了配置列對話框中的關聯類型選擇界面元素
  3. 修改了保存列配置的代碼，保留字典引用而不是強制移除
- **實現效果**：
  1. 用戶現在可以同時勾選並配置關聯字段和字典子表功能
  2. 界面更加簡潔，不再顯示關聯類型選擇
  3. 兩種功能同時啟用時系統可以正常工作，數據一致性得到保障

## 20231128 15:00 高级选项：关联字段功能优化及修复

### 功能需求
- 高级选项：关联字段，剔除关联类型
- 新增和维护原有栏位时，支持选择任意数据类型去关联
- 关联后，在字段栏位里用小字写明和哪个表格关联了

### 具体实现
1. 修改DataTable.tsx文件中高级选项的关联字段复选框逻辑，从类型切换改为可选功能
2. 在新增栏位和编辑栏位对话框中添加完整的关联关系配置界面
3. 优化SortableHeader组件，在表头中显示关联表信息（小字）
4. 修改saveColumnConfig函数，移除字典引用相关代码，优化关联字段保存逻辑
5. 保存关联表名称信息到targetTableName字段

### 问题修复
1. 修复SortableHeader组件中缺少allTables参数的错误
2. 为SortableHeaderProps接口添加allTables参数定义
3. 在SortableHeader组件调用时传递allTables参数
4. 修复relation对象类型不匹配问题，确保targetTableId和type字段始终有默认值

### 实现效果
- 任何数据类型都可以设置关联字段
- 界面清晰显示关联表信息
- 关联配置正确保存并在表头中展示
- 修复了运行时错误，组件能够正常工作

## 修复你提到的三类问题：历史记录乱码、历史详情超出窗口、卡片视图附件名称乱码。以下为具体改动、原因说明与验证建议。

修复内容

- 服务器端文件名编码
  
  - 在 server/routes/rows.js 中新增 normalizeOriginalName ，将可能被 latin1 解码的浏览器上传文件名转回 utf8 ，并清理不可见字符与非法路径符。
  - 上传时使用修正后的文件名生成磁盘文件名： uniqueSuffix + '-' + originalName ，避免原始中文名出现“�”乱码。
  - 附件元数据字段统一使用修正后的 name ，同时将 URL 的文件名片段用 encodeURIComponent 编码，确保链接在浏览器中可访问且不产生乱码。
  - 删除附件时，若存在物理文件则尝试 unlinkSync 清理；行数据中移除对应字段，避免残留无效路径。
- 历史详情对话框渲染与溢出
  
  - 在 src/App.tsx 历史详情对话框将宽度调整为 max-w-[80vw] sm:max-w-3xl ，内容区高度为 max-h-[60vh] overflow-auto ，避免在内容较多时超出视窗。
  - 变更内容区对对象值使用 JSON.stringify(ch.before, null, 2) / JSON.stringify(ch.after, null, 2) ，并通过 whitespace-pre-wrap 与 break-words 保证长文本自动换行，去除横向溢出。
  - 行内文本也应用 break-words ，同时为删除线及对比展示保留可读性。
- 卡片视图附件名称显示
  
  - 在 src/components/CardView.tsx 的附件显示中，为文件名链接添加 title={value.name} ，并使用截断类名保持布局整洁；依赖服务器端编码修正后，名称将正确显示中文，不再乱码。
问题成因与修复效果

- 乱码根因：浏览器上传时， multer/busboy 在部分环境下把 Content-Disposition 的 filename 用 latin1 解析，中文会变成“�”。服务端用 Buffer.from(name, 'latin1').toString('utf8') 可还原正确的中文。
- 历史详情溢出：对话框固定宽度且内容容器 max-h-64 ，长 JSON（包含 Windows 路径与 URL）会超出窗口。通过扩大对话框宽度、高度按视窗百分比限制、为内容开启换行与滚动，确保完整可读且不溢出。
- 卡片视图名称：表面来自前端 UI，但根因是服务端存入了乱码；修复服务端后前端正常显示，并提供 title 便于悬停查看全名。
如何在本地验证

- 历史详情
  - 在 http://localhost:5001/ 中上传一个包含中文名称的附件，例如 姓名啊啊啊 (1) - 測試.png 。
  - 打开历史列表，查看“歷史詳情”对话框的“數據變更”，应显示正常中文，且内容在窗口内自动换行或滚动，无横向溢出。
- 卡片视图附件
  - 在卡片视图查看该附件，链接文本应为正确中文，悬停显示完整文件名，点击能正确打开。
- 链接访问
  - 确认附件链接路径包含编码过的文件名片段，点击可访问图片内容，无 404。
后续可选优化

- 在历史详情中对文件对象仅展示关键字段（如 name 与 url ），为 path 提供可折叠区块减少视觉噪音。
- 如需支持更严格的文件名清理/规范化，可增加白名单字符集或统一替换空格为下划线。
- 如果你希望删除附件不移除物理文件（以便回滚），可以改为仅清空行数据引用并保留磁盘文件；目前实现是硬删除以避免堆积。
如果你希望历史详情进一步只显示“前值/后值”的人类友好格式而不是完整 JSON，我可以继续调整渲染逻辑。也欢迎告诉我是否要在历史详情里隐藏 path 字段。


## 系统需新增一项可维护其他账号权限的高级权限功能。具体实现要求如下：当密码登录的管理员账号或后续创建的普通账号在登录时，若系统检索到其foundation数据满足预设条件，则自动赋予该账号高级权限。高级权限账号登录系统后，界面应显示权限设置功能模块；非高级权限账号登录时，权限设置功能模块应隐藏且不可访问。

- 高级权限判定
  - 基于登录来源自动判定是否具备高级权限：
    - 管理员密码登录后自动赋予 admin.manage 。
    - Foundation 登录成功时，若满足预设条件（角色为 admin 、权限包含 admin.manage 、群组包含 permission-admin 、或 isAdvanced === true ），自动在权限集中加入 admin.manage 。
  - 统一通过 canAccessPermissionSettings 控制界面显示/隐藏： (currentRole === 'admin') || currentPermissions.includes('admin.manage') 。
- 权限设置模块显隐
  - 右键菜单增加“權限設置”项，并在非高级权限账号登录时隐藏且不可访问。
  - 权限设置对话框整体使用条件渲染包裹，确保非高级权限用户不会渲染此模块。
- 管理其他账号权限
  - 在“權限設置”对话框中新增“目標使用者”输入框，可输入要配置的用户账号。
  - 保存逻辑优先使用 targetUsername ；未输入时回退到当前登录用户。
  - 仅当编辑的是当前登录用户时，才同步更新本地 localStorage （避免误将他人角色/权限写入本地）。
验证结果

- 我已启动后端 http://localhost:8001 与前端 http://localhost:5001 并打开预览。
- 浏览器未显示错误；终端已恢复运行，前端服务成功启动且代理配置指向后端端口。
- 权限设置模块显隐逻辑正常：
  - 未具备高级权限时，右键菜单不显示“權限設置”，也不会渲染对应对话框。
  - 管理员密码登录或满足 Foundation 高级权限条件时，显示并可打开“權限設置”。
使用说明

- 管理员密码登录
  - 在页面底部当前用户条目中点击“登入”，输入管理员密码后登录。
  - 登录成功后自动包含高级权限，右键菜单将显示“權限設置”。
- Foundation 登录
  - 点击“使用 Foundation 登入”并完成验证。
  - 若后端返回的 role/groups/permissions/isAdvanced 满足高级权限预设，系统自动赋予高级权限并显示“權限設置”。
- 配置其他账号权限
  - 打开“權限設置”后，先在“目標使用者”中填入要设置的账户，再选择角色并勾选权限。
  - 点击“保存”后，将调用后端 /users/:username/settings 保存；若目标用户为当前登录账户，同时更新本地 localStorage 。
后续可微调

- 预设条件来源：目前在前端根据 Foundation 消息结构做判断；如果后端明确提供“高级权限”标记字段，我们可以改为以该字段为主。
- 枚举常量抽离：建议将角色、权限枚举及高级权限规则抽离到 src/constants/permissions.ts ，并与后端权限码对齐，减少前后端偏差。
- 表单校验：为“目標使用者”增加基本校验（必填、格式），并在保存前弹出确认提示。
- 操作审计：保存他人权限时，在后端记录操作人、目标人与变更内容，以便审计。
如果你希望我把角色/权限枚举和高级权限规则抽离到常量文件，并补充类型定义与说明注释，我可以继续完善。

##  新增角色權限窗口查看UI

- 展开/折叠分类
  - 每个权限类别以原生 details/summary 交互呈现，点击可展开或收合。
  - 列表过长的类别默认收合（长度≤4的类别默认展开），减少视觉负担。
  - 每项权限包含标签与描述，关键权限项附“CRITICAL”标识，便于快速识别。
- 角色说明区
  - 顶部加入“角色說明”区块（可展开/收合）。
  - 根据 currentRole 提示角色级别能力说明；未匹配角色时给出指引文案。
结构与布局

- 顶部摘要
  - 显示： 角色：{currentRole || '未設定'} ｜ 權限數：{total}
  - “關鍵權限”列表突出展示，便于管理者快速把控风险项。
- 角色说明
  - 使用 details/summary 提供角色能力说明（ admin/editor/member/viewer 等），语义清晰。
- 分类分组
  - 权限按类别分组展示，支持点击展开/收合。
  - 每项包含“名称标签 + 描述说明”，提升理解与辨识效率。
交互说明

- 展开/折叠分类
  - 点击分类标题右侧“展開/收合”即可切换状态。
  - 默认策略：权限项≤4的类别自动展开；更长的列表默认收合。
- 角色说明
  - 点击“角色說明”标题即可展开或收合角色能力说明。
可微调项

- 默认展开策略：可将 open={perms.length <= 4} 调整为按类别或角色策略决定。
- 角色映射：当前在权限窗口内定义了 roleDescMap ，你可将其抽离到 src/constants/roles.ts 并统一管理。
- 文案与样式：标签与描述已采用 Tailwind 类名（如 text-sm , text-gray-600 , bg-red-50 ），可按你主题规范细化。
验证建议

- 使用管理员角色打开权限窗口，确认“關鍵權限”与“角色說明”显示完整。
- 切换到普通用户角色，确认权限类别中仅展示授权项、展开/收合交互正常。
- 长列表类别（>4项）默认收合，点击展开后列表显示完整且描述清晰。
如果你希望我把角色说明与权限映射抽离为常量文件以便维护，或为展开状态加持久化（例如根据用户上次展开偏好保存在 localStorage ），我可以继续优化。

## 修正了你提出的权限查看窗口的实现问题，并已经在预览中确认没有运行错误。接下来是这次优化的具体内容与使用说明。

改动概要

- 将权限映射、分类与说明逻辑移至对话框内的渲染闭包中，避免未定义引用导致的运行错误。
- 权限信息按“类别”分组展示，并在顶部加入关键权限摘要。
- 描述信息明确每项权限的实际作用，提升可读性与理解成本。
- 视觉上突出“关键权限”（如写入/管理类），并在底部提供完整权限列表以避免遗漏。
UI布局

- 顶部摘要区
  - 当前角色与总权限数。
  - 关键权限条目以强调样式展示（如“修改表格”、“修改行”、“系統管理”等）。
- 分类分组区
  - 按类别分组展示（表格、數據、文件、版本、系統）。
  - 每项权限包含“名称标签”与“描述说明”，减少误解。
- 完整信息区
  - 展示用户拥有的全部权限项，确保信息完整但不冗余。
关键行为

- 权限计算
  - admin 角色自动拥有所有权限。
  - 非管理员角色读取其 currentPermissions 数组作为有效权限集合。
- 权限分组与显示
  - 使用 PERMISSION_MAP 映射到 label/category/description/critical 。
  - 通过 groupByCategory(effective) 生成分类结构。
  - 关键项通过 isCritical(permission) 高亮。
已修复错误

- 预览中曾出现 ReferenceError: getEffectivePermissions is not defined 。
- 我已将权限映射与工具函数定义放置到渲染闭包内部，确保作用域正确并避免未定义引用。
- 现在预览无错误；建议也看下终端是否有来自构建工具的警告。
验证建议

- 右键打开权限查看窗口，确认：
  - 顶部显示当前角色与关键权限摘要。
  - 权限按类别分组排列，描述语义清晰。
  - 管理员账号显示所有权限；普通用户仅显示自身权限。
- 若需自定义权限项或名称：
  - 可以在 PERMISSION_MAP 中增减权限条目，或修改 label/description/category/critical ，以适配你的业务域。
后续可选优化

- 支持搜索权限项：允许输入关键字过滤权限列表。
- 展开/折叠分类：减少长列表下的视觉负担。
- 国际化文本：将 label 与 description 接入你的 i18n 管线。
- 角色说明区：增加角色级别的简要能力说明，帮助用户理解差异。
如果你希望我为 PERMISSION_MAP 对接你的后端权限码或统一权限枚举，我可以继续把映射抽离到 src/constants/permissions.ts 并在权限窗口中引入，保持维护一致性。是否需要继续这一步？

## 新增功能管理員密碼登入：在登入對話框中加入密碼輸入框與「管理員登入」按鈕，密碼為20251028。
登入成功行為：設置本地狀態與存儲，currentUserName與foundation_user_role分別置為admin，並顯示「管理員登入成功」提示。
操作位置

組件狀態新增：
adminPassword輸入狀態
ADMIN_PASSWORD常量與handleAdminLogin函數
登入對話框更新：
增加「管理員密碼」Input與「管理員登入」Button
調整文案以提示可選擇 Foundation 或管理員密碼登入

如需更改管理員顯示名稱或角色權限行為，告訴我你的期望（例如設置特定權限集）。

## 
- 历史 API 扩展：在前端 ApiService 中新增与修改历史相关方法， createHistorySnapshot 自动附带当前登录用户 actor ，历史列表与详情接口返回 actor 。
- 历史列表显示：历史下拉菜单项文本中追加用户信息，格式为“由 {actor}”，无用户时显示“未知用户”。
- 详情模态框：点击历史项打开详情弹窗，清晰展示用户名、操作来源、时间、本地与 PST 格式、以及前后快照的差异对比。
- 回溯操作：在详情弹窗中提供“回溯到此版本”按钮，沿用现有回溯逻辑，确保追溯性与可用性。
- UI 验证：已启动本地预览并打开页面进行验证（ http://localhost:5001/ ）。
如何验证

- 打开 http://localhost:5001/ 。
- 在顶部或目标表的历史下拉菜单中找到历史记录条目。
- 每条历史记录应显示：
  - 操作标签与来源（如“用户操作”“系统生成”等）
  - 操作时间（相对时间与格式化时间）
  - 用户信息： 由 {actor} ；如无信息显示“未知用户”
- 点击历史记录项，详情弹窗应展示：
  - actor 用户名
  - 操作来源与时间（本地时区与 PST）
  - 详细差异对比（新增、更新、删除的表/字段/行等内容）
  - “回溯到此版本”按钮可正常执行回溯，且关闭弹窗和刷新历史列表状态。
数据准确与可追溯性

- actor 来源： ApiService.createHistorySnapshot 在每次快照创建时自动读取 localStorage.getItem("username") ，并作为 actor 提交。确保用户登录流程在成功登录后写入该键。
- 历史列表与详情：前端从接口读取包含 actor 的历史条目，列表与详情均展示相同用户信息。
- 差异对比：通过 computeSnapshotDiff(prevSnapshot, nextSnapshot) 提取结构化差异，避免误报，支持多类型对象差异输出。
可能的后续优化

- 若后端尚未保存 actor 字段，需要配合后端接口更新存储逻辑（历史表结构、创建快照的服务层）。
- 在无 localStorage.username 时，可退回到服务端的用户标识；或在前端显示更明确的提示。
- 为差异输出添加语义分组与更丰富的高亮样式，提升可读性。
如果你希望我继续验证某个具体表或操作的整条历史链条，或完善后端的 actor 持久化，请告诉我你当前的登录写入方式以及后端历史表结构。

##  補充 CardView 上傳功能
- CardView.tsx 補充 handleFileUpload 實作，並加入認證拦截。
- 打開預覽 http://localhost:5001/ 以驗證登入 UI 與拦截效果。
代碼變更

- 新增 handleFileUpload 並在未登入時阻止上傳：
  - 位置： src/components/CardView.tsx ，定義於 renderFieldInput 之前。
  - 行為：未登入顯示 toast.error('未登入，禁止上傳') ，已登入則生成 ObjectURL 並回傳 { name, url, size, type } 。
用戶體驗

- 未登入時：
  - 所有新增、刪除、編輯、上傳、重傳、刪附件操作均被攔截並提示不可操作。
  - App 頂部顯示「登入」按鈕，點擊可打開對話框，選擇以 Foundation 登入。
- 登入後：
  - localStorage 保存 foundation_user_name 和 currentUserName 。
  - 所有上述操作恢復可用，文件欄位上傳顯示檔名並可點擊連結。
測試建議

- 在瀏覽器預覽頁：
  - 檢查頂部「當前操作用戶」是否為「未登入」；嘗試在表格與卡片視圖新增/編輯/刪除/上傳，應出現阻止提示。
  - 點擊「登入」→ 選擇 Foundation 登入 → 完成後應更新為當前用戶名，並可正常執行各操作。
  - 在卡片視圖的檔案欄位選擇檔案，應成功顯示檔名且可點擊連結。
後續可優化（可選）

- 在登出時清理 foundation_user_name 、 currentUserName 與任何臨時 ObjectURL 。
- 將 isAuthenticated 抽到公用 util 並在各組件重用，避免重複邏輯。
- 若日後接入後端上傳，替換 ObjectURL 為後端返回的永久 URL。

##  把“权限设置”对话框改为同时展示“角色选择 + 权限勾选”，并新增后端接口与之联动保存。接着我会启动后端和前端，预览并验证交互。

- 已新增后端用户设置接口并接入前端保存
- 已更新前端对话框，在同一处同时选择“角色 + 权限”
实现概览

- 新增后端接口
  - GET /api/users/:username/settings 返回该用户的角色与权限
  - PUT /api/users/:username/settings 保存该用户的角色与权限（支持 upsert）
- 数据库新增表 user_settings 用于持久化角色与权限
- 前端 apiService 增加 getUserSettings 与 updateUserSettings
- 前端把“权限设置”对话框改为“角色选择 + 权限勾选”合一，并保存时调用后端接口
关键改动位置

- server/db/database.js
  - 增加表创建： user_settings
  - 新增方法： getUserSettings(username) 、 upsertUserSettings(username, role, permissions)
- server/routes/users.js 新增路由文件（加载与保存用户设置）
- server/server.js 增加路由挂载： app.use('/api/users', require('./routes/users'));
- src/lib/api.ts
  - 新增方法： getUserSettings(username) 与 updateUserSettings(username, { role, permissions })
- src/App.tsx
  - 导入选择组件： Select, SelectTrigger, SelectContent, SelectItem, SelectValue
  - 将“权限设置”对话框改为同一框中包含：
    - 角色选择（示例值： 訪客 、 編輯者 、 管理員 、 擁有者 ）
    - 权限勾选（示例权限： 讀取 、 寫入 、 刪除 、 管理 ）
    - 保存时调用 apiService.updateUserSettings(currentUserName, { role, permissions }) 成功后写入 localStorage 并 toast 成功
- vite.config.ts 将 proxy['/api'].target 更新为 http://localhost:8001 （避免 8000 端口占用）
运行与预览

- 后端：在 server 目录执行 npm run dev 已启动在 http://localhost:8001/ （已运行）
- 前端：在项目根目录执行 npm run dev ，开发服务器运行在 http://localhost:5001/ （已重启）
- 预览地址： http://localhost:5001/
- 验证步骤：
  - 在侧栏底部“当前操作用户”区域右键 -> 选择“權限設置”
  - 在弹窗中选择角色（ 訪客/編輯者/管理員/擁有者 ）并勾选权限（ 讀取/寫入/刪除/管理 ）
  - 点击“保存”，应出现“已保存角色與權限（已同步後端）”
  - 若未设置 currentUserName ，会提示“請先登入或設定使用者名”
  - 后端终端可观察到请求日志；如失败会 toast 错误并在控制台输出详细异常
后端数据结构

- 表 user_settings 字段
  - id 主键
  - username 唯一标识当前用户
  - role 字符串角色
  - permissions 文本，存储为 JSON 数组字符串
  - updated_at 更新时间
- 接口返回示例（GET）
  - 成功： { username, role: '編輯者', permissions: ['讀取', '寫入'] }
  - 没有记录时： { username, role: null, permissions: [] }
- 保存示例（PUT 请求体）
  - {"role":"管理員","permissions":["讀取","寫入","刪除","管理"]}
说明与后续

- 角色与权限的选项为示例占位，可与 foundation 权限模型对齐后再调整枚举项与含义。
- 保存成功后会同步写入 localStorage （键： foundation_user_role 、 foundation_user_permissions ），以便前端展示与离线状态。
- 如需打开时自动拉取后端设置，可在打开“權限設置”时调用 apiService.getUserSettings(currentUserName) 初始化状态（我可以加上这一步）。
- 当前前端通过 Vite 代理转发到 8001 ，如果你的后端希望使用 8000 ，可以改回代理并确保端口不冲突。
如果你希望我在打开“權限設置”时自动从后端拉取初始化角色和权限，请告诉我，我可以补上对应的 useEffect 或在打开对话框时触发拉取的逻辑。


## 在侧栏“當前操作用戶”上增加右键菜单，包含登出、查看權限、權限設置三项，并完成基础交互与对话框。

新增内容

- 在侧栏底部用户显示处支持右键菜单：
  - 登出：清空 localStorage 中的用户与权限信息，重置前端状态并显示成功提示。
  - 查看權限：弹出对话框展示当前用户、角色及权限列表（读取 foundation_user_role 与 foundation_user_permissions ）。
  - 權限設置：弹出对话框提供“讀取/寫入/刪除/管理”四项权限勾选，保存到 localStorage 并更新展示。
关键实现位置

- 文件： c:\Users\DARREN.C\nocodb-web-portal\nocodb-web-portal\src\App.tsx
- 变更点：
  - 导入： ContextMenu 组件集（ @/components/ui/context-menu ）。
  - 新增状态： currentRole 、 currentPermissions 、 isPermissionsDialogOpen 、 isPermissionsSettingsOpen 。
  - 初始化逻辑： useEffect 从 localStorage 读取用户名、角色与权限，支持 JSON 数组和逗号分隔字符串。
  - 右键菜单：用 ContextMenu 包裹用户显示；点击“登出/查看權限/權限設置”触发对应逻辑。
  - 对话框：放置于侧栏底部容器中，Radix Dialog 以 Portal 显示，不影响布局。
使用与验证

- 运行前端： npm run dev ，预览地址 http://localhost:5001/ 。
- 右键点击“當前操作用戶：…”可打开菜单：
  - 选择“查看權限”查看当前权限。
  - 选择“權限設置”勾选并保存，将写入 localStorage 的 foundation_user_permissions 。
  - 选择“登出”清空本地用户信息并重置显示为“未登入”。
与 foundation 登录的对接建议

- 登录成功后，将用户信息写入本地以联动显示：
  - localStorage.setItem('foundation_user_name', user.name)
  - localStorage.setItem('foundation_user_role', user.role)
  - localStorage.setItem('foundation_user_permissions', JSON.stringify(user.permissions))
- 如需无刷新同步，可增加事件机制：
  - 组件内监听： window.addEventListener('foundation:user', e => { setCurrentUserName(e.detail?.name); setCurrentRole(e.detail?.role); setCurrentPermissions(e.detail?.permissions || []); })
  - 登录成功处派发： window.dispatchEvent(new CustomEvent('foundation:user', { detail: { name, role, permissions } }))
可选增强

- 在“權限設置”中增加“角色选择”下拉（例如 viewer/editor/admin ），保存到 foundation_user_role 并在“查看權限”中展示。
- 增加“登出”后的一次性提示弹窗与回到欢迎页的引导。


## 我先在侧栏找到“反馈建议入口”，并插入“当前操作用户”显示；随后启动前端服务器并打开预览验证。

改动概述

- 在 src/App.tsx 侧栏底部区域（反馈入口上方）新增“當前操作用戶”展示。
- 通过读取 localStorage 的 currentUserName 或 foundation_user_name 显示用户名；无值时显示“未登入”。
- 引入 lucide-react 的 User 图标，保持与现有风格一致。
具体实现

- 位置： c:\Users\DARREN.C\nocodb-web-portal\nocodb-web-portal\src\App.tsx
- 主要变更：
  - 导入图标： import { ..., User } from 'lucide-react'
  - 新增状态与初始化：
    - const [currentUserName, setCurrentUserName] = useState<string | null>(null);
    - useEffect 从 localStorage 读取 currentUserName 或 foundation_user_name
  - 侧栏底部 JSX（反馈入口上方）：
    - 添加一行用户展示： 當前操作用戶：{currentUserName || '未登入'} ，带 User 图标
预览验证

- 已启动前端开发服务器并打开预览： http://localhost:5001/
- 验证位置：侧栏底部区域，“反馈建议入口”上方应看到“當前操作用戶：未登入”或实际用户名。
后续接入 foundation 的建议

- 简易打底方式（不改代码即可验证显示）：
  - 在浏览器控制台执行： localStorage.setItem('foundation_user_name', 'DARREN') 后刷新页面。
- 接入策略建议：
  - 当 foundation 完成登录后，在登录成功回调中写入： localStorage.setItem('foundation_user_name', user.name) 并触发刷新或状态更新。
  - 如需无刷新更新，可在后续迭代添加事件监听，例如在 App.tsx 中增加：
    - 监听自定义事件： window.addEventListener('foundation:user', e => setCurrentUserName(e.detail?.name))
    - 在登录成功处派发事件： window.dispatchEvent(new CustomEvent('foundation:user', { detail: { name: user.name } }))
- 若需要显示更多信息（头像、角色、登出按钮）：
  - 可扩展为对象状态 currentUser （含 name , avatarUrl , role 等），在侧栏展示头像或下拉菜单。
注意与可调整项

- 文案语言当前采用繁体字风格（與現有 UI 一致）；可按需改为简体，如“当前操作用户：未登录”。
- 本次仅新增展示，不影响现有表格、历史、导出等功能。
- 若需把“未登入”替换为“請登入”，可直接改为： {currentUserName || '請登入'} 。

## 2025-10-22 回滾操作徽章顯示優化

- 變更項目：回滾操作徽章顯示功能優化
- 變更原因：原徽章無法清晰區分「回滾」與普通操作，且來源與具體內容提示不夠直觀。
- 變更目的：提升可讀性與可追溯性，以「相對時間 · 視圖名稱 · 操作動作：細節」標準格式顯示。

- 主要調整：
  - 新增標籤規則：操作標籤支持「動作 | 細節」分隔，示例：`行順序調整 | 第2行順序調整到第6行`。
  - 行拖拽事件中，使用當前可視索引組裝細節內容：`第${oldIndex+1}行順序調整到第${newIndex+1}行`。
  - 徽章渲染重構：優先顯示相對時間，其次視圖名稱，最後顯示「操作動作：細節」，不再附加固定尾註。
  - 兼容回滾顯示：撤銷後仍按上述格式展示（動作部分會包含「撤銷：」前綴）。

- 受影響文件：
  - `src/App.tsx`

- 驗收建議：
  - 在表格視圖進行一次可回滾操作（如拖動行順序），檢查徽章顯示為「最近操作：表格視圖 · 行順序調整 · 相對時間」。
  - 點擊「回滾上次操作」，確認徽章更新為「最近操作：表格視圖 · 撤銷：行順序調整 · 相對時間」。
  - 在卡片視圖進行操作與回滾，確認來源顯示為「卡片視圖」。

- 兼容性與風險：
  - 不影響原有回滾堆疊邏輯；僅新增展示狀態，無資料變更風險。
  - 當不存在操作或堆疊為空時，徽章不顯示。

- 版本標記：
  - 屬於前端 UI 改進，無需後端版本變更。

## 2025-10-22 行拖拽本地持久化存儲

- 變更項目：表格行拖拽順序的本地持久化存儲
- 變更原因：行拖拽後的順序在刷新頁面後未保留，影響使用體驗與一致性。
- 變更目的：在瀏覽器端持久化保存每個表的行順序，保證刷新或重開頁面後的展示一致。

- 主要調整：
  - 新增本地持久化工具：以 `tableRowOrder:<tableId>` 作為鍵，將行 ID 順序持久化到 `localStorage`。
  - 在 `useTables` 中應用本地順序：
    - `loadTables` 讀取行數據後按本地順序重排。
    - `updateTable` 接收到行順序變更時保存至本地。
    - `createRow` / `deleteRow` / `batchUpdateRows` 在重新加載行數據後按本地順序重排並同步本地映射，保持映射健康。
  - 與現有拖拽邏輯對齊：`DataTable` 的拖拽完成後通過 `onUpdateTable` 更新行順序，觸發持久化。

- 受影響文件：
  - `src/hooks/use-tables.ts`
  - `src/components/DataTable.tsx`（依賴 `onUpdateTable` 觸發持久化）

- 驗收建議：
  - 在表格視圖拖拽調整多行順序，刷新頁面後檢查行順序是否保持不變。
  - 新增或刪除行後再次刷新，確認本地映射同步且順序仍正確。
  - 切換到卡片視圖檢查展示順序一致。

- 兼容性與風險：
  - 新增：行拖拽順序本地持久化至 `better-sqlite3`，不使用瀏覽器緩存，避免刷新後改動消失。
    - 後端：
      - 新增資料表 `row_orders(table_id, row_id, position)` 持久化行順序。
      - 調整行查詢為按持久化順序返回：`GET /api/tables/:tableId/rows` 依據 `row_orders.position` 排序，無序的行按 `created_at` 置後。
      - 新增 API：`GET /api/tables/:tableId/rows/order` 讀取順序；`PUT /api/tables/:tableId/rows/order` 保存順序。
    - 前端：
      - 移除 `localStorage` 行序列映射，全部改為調用後端 API。
      - 在 `use-tables.updateTable()` 於更新表結構後，保存當前 `rows` 的 `id` 順序至後端。
      - `loadTables / createRow / updateRow / deleteRow / batchUpdateRows` 均依賴後端已排序的返回結果。
    - 開發環境：請啟動後端服務（`server` 目錄 `npm run dev`，預設 `http://localhost:8000`），前端 `vite` 代理 `/api` 至 8000 端口。

## 2025-10-22 表格視圖操作詳細標籤與徽章接入

- 變更項目：統一表格視圖操作標籤格式為「動作 | 細節」，接入徽章渲染並顯示具體細節
- 變更原因：原標籤僅顯示動作名稱，缺少具體上下文信息，無法在徽章中快速判斷操作內容
- 變更目的：提升操作可視化與審計友好度，與頁頭徽章的「相對時間 · 視圖名稱 · 操作動作：細節」渲染規則完全對齊

- 標籤規則：統一使用「動作 | 細節」格式；若包含括號補充，徽章端將自動清理括號內容

- 表格視圖動作映射：
  - 欄位設定變更 | 欄位：<欄位名稱>，變更筆數：<N>
  - 欄位順序調整 | <欄位名稱>：<舊索引> → <新索引>
  - 行順序調整 | ID：<行ID>：<舊索引> → <新索引>
  - 新增欄位 | <欄位名稱>（<類型>）
  - 刪除欄位 | <欄位名稱>（索引：<原索引>）
  - 新增行 | ID：<行ID>
  - 刪除行 | ID：<行ID>（索引：<原索引>）
  - 單元格編輯 | 欄位：<欄位名稱>，行：<行ID>，<舊值> → <新值>
  - 批量刪除 | 筆數：<N>
  - 批量編輯 | 欄位：<欄位名稱>，筆數：<N>，值：<目標值>
  - 批量複製 | 筆數：<N>

- 受影響文件：
  - `src/components/DataTable.tsx`

- 驗收建議：
  - 逐一測試上述操作，觀察頁頭徽章是否顯示詳細內容（來源應為「表格視圖」）
  - 測試回滾按鈕，確認徽章顯示為「撤銷：<動作 | 細節>」，且來源與時間準確

- 兼容性與風險：
  - 僅改動標籤字串，不影響原業務流程；若值類型為複雜物件，徽章可能顯示為通用字串（可後續優化格式化）

- 版本標記：
  - 前端展示優化，無需後端變更

## 2025-10-22 新增歷史修改記錄與任意版本回溯

- 變更項目：新增「歷史修改記錄」功能，支持持久化存儲並回溯到任意歷史版本；在「回滾上次操作」按鈕右側新增入口。
- 變更目的：提升審計可追溯性與可恢復能力，支持跨多次操作的版本選擇性回復。

- 主要功能：
  - 本地持久化歷史：每次資料修改後保存當前子表快照（名稱、欄位、行及順序）到 `localStorage`，按表分組管理。
  - 任意版本回溯：從歷史列表選擇任一版本，系統將同步更新表結構、補齊缺失行、刪除多餘行、批量更新現有行，並對齊行順序。
  - 入口位置：在「回滾上次操作」按鈕右側新增「歷史記錄」下拉菜單，展示「標籤 + 相對時間 + 來源」，支持一鍵回溯與清空當前表歷史。

- 受影響文件：
  - `src/App.tsx`

- 使用說明：
  - 進行任何資料修改（如新增/刪除行、編輯單元格、批量操作等）後，系統自動生成快照。
  - 點擊頁頭「歷史記錄」下拉，選擇目標版本即可回溯；如需重置歷史，點選「清空當前表歷史」。

- 兼容性與風險：
  - 歷史存儲採用前端 `localStorage`，僅針對本機瀏覽器；如需多人協同歷史，後續可擴展至後端存儲。
  - 回溯操作將調用後端 API 進行同步（更新結構、增刪改行、重排順序）；在大量資料下可能帶來一定延時。

- 驗收建議：
  - 在表格或卡片視圖執行多次操作，打開「歷史記錄」查看版本列表；選擇任意版本回溯，確認資料與行順序與該版本一致。
  - 測試「清空當前表歷史」後，歷史列表應顯示為空。

- 版本標記：
  - 前端功能新增，後端沿用現有 API 以完成回溯時的資料同步。
