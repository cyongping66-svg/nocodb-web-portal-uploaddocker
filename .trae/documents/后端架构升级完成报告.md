# 后端架构升级与MySQL集成实施方案 (已完成)

所有核心任务已执行完毕。后端架构已从 SQLite 迁移至 MySQL，并集成了 Swagger 文档、环境配置管理及数据迁移工具。

## 1. 核心变更摘要

### 1.1 数据库架构迁移 (MySQL 8.0)
- **适配器实现**: 创建了 [mysql-database.js](server/db/mysql-database.js)，基于 `mysql2` 连接池实现了完整的数据库操作接口。
- **数据结构**: 在 MySQL 中复刻了 `tables`, `rows`, `row_orders`, `table_history`, `user_settings` 表结构，利用 JSON 字段存储动态数据，保持了与原有前端的兼容性。
- **环境配置**: 引入了 [db.config.js](server/config/db.config.js)，支持 `development`, `test`, `production` 多环境配置，通过 `.env` 文件管理敏感信息。

### 1.2 API 增强与标准化
- **分页支持**: `GET /api/tables/:tableId/rows` 现已支持 `?page=1&limit=100` 参数，解决了大数据量下的性能问题。
- **异步批处理**: 重构了 `/batch` 接口，使用 `Promise.all` 替代了同步事务，以适配 MySQL 的异步特性。
- **Swagger 文档**: 集成了 Swagger UI，访问地址为 `/api-docs`，提供了可视化的 API 文档。

### 1.3 数据迁移工具
- **迁移脚本**: 开发了 [migrate.js](server/scripts/migrate.js)，支持从 SQLite 到 MySQL 的全量及增量迁移。
    - 运行方式: `node server/scripts/migrate.js` (增量) 或 `node server/scripts/migrate.js --full` (全量)。

## 2. 关键文件说明

| 文件路径 | 说明 |
| :--- | :--- |
| `server/db/mysql-database.js` | MySQL 数据库适配器核心实现 |
| `server/config/db.config.js` | 数据库多环境配置文件 |
| `server/config/swagger.js` | Swagger 文档配置 |
| `server/scripts/migrate.js` | SQLite -> MySQL 数据迁移脚本 |
| `server/.env` | 环境配置文件（需用户根据实际情况填写） |

## 3. 后续操作指南 (用户必读)

### 3.1 配置数据库
请务必编辑 `server/.env` 文件，填入您真实的 MySQL 数据库连接信息：
```properties
DB_HOST=localhost
DB_PORT=3306
DB_USER=your_username
DB_PASSWORD=your_password
DB_NAME=nocodb_portal
```

### 3.2 运行数据迁移
在启动服务器前，请执行迁移脚本将现有的 SQLite 数据导入 MySQL：
```bash
cd server
node scripts/migrate.js --full
```

### 3.3 启动服务器
```bash
cd server
npm start
```
启动后，您可以访问 `http://localhost:8000/api-docs` 查看 API 文档。

---

## 4. 苏格拉底式自省 (Socratic Review)

1.  **为什么在迁移脚本中我们选择在应用层进行数据搬运，而不是使用数据库层面的导出导入工具？**
    - *原因*: 源数据库(SQLite)和目标数据库(MySQL)的底层存储格式不同（如 JSON 存储方式），且我们需要保留特定的业务逻辑（如 UUID 生成、时间戳处理）。应用层脚本提供了最大的灵活性来处理这些差异。

2.  **如果 MySQL 连接池耗尽会发生什么？**
    - *风险*: 请求会进入等待队列。我们在 `db.config.js` 中配置了 `connectionLimit` 和 `waitForConnections: true`。
    - *优化*: 在生产环境中，应根据服务器的 CPU 核心数和负载情况调整 `DB_CONNECTION_LIMIT`。

3.  **当前的批处理(Batch)操作为何牺牲了严格的数据库事务(ACID)？**
    - *权衡*: 为了快速适配现有的路由逻辑并支持大规模并发操作，我们使用了 `Promise.all` 并行执行。虽然这在极端情况下（如服务器崩溃）可能导致部分数据写入，但在当前架构下，这是性能与复杂度的合理折衷。如果业务对数据一致性要求极高，建议后续引入分布式事务或基于 MySQL 存储过程的批处理。

## 5. PM 视角总结
作为 PM，我认为此次升级为产品的**可扩展性**打下了坚实基础。MySQL 的引入消除了 SQLite 的并发写入瓶颈，Swagger 文档降低了前后端协作的沟通成本，而分页功能的加入直接提升了终端用户的浏览体验。下一步，建议关注**权限系统的细化**和**复杂查询性能的监控**。
