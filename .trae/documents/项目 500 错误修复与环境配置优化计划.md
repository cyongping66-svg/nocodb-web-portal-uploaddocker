# 针对 500 错误及项目运行问题的综合修复方案

根据您提供的日志和代码分析，我们已经定位了导致 "API request failed: 500"、登录失败以及 Docker 部署问题的核心原因。以下是详细的修复计划：

## 一、 核心问题分析 (500 错误与连接失败)

1.  **500 错误根源**：后端代码 (`tables.js`, `rows.js`) 在处理数据库数据时，强制使用了 `JSON.parse`。由于我们从 SQLite 迁移到了 MySQL，MySQL 驱动返回的数据可能已经是对象格式，再次解析会导致服务器崩溃抛出 500 错误。
2.  **本地数据库连接失败**：您的后端服务如果在本地运行（非 Docker 内部），无法连接到数据库，因为 `docker-compose.yml` 中的 MySQL 服务没有向宿主机暴露 `3306` 端口。
3.  **N+1 性能陷阱**：前端 `use-tables.ts` 采用"先查表单，再循环查每张表数据"的低效逻辑，导致页面加载时瞬间发起大量请求，极易触发数据库拒绝服务。

## 二、 修复计划

### 1. 修复数据库连接 (优先级：高)
**目标**：确保本地开发环境能正常连接 Docker 中的 MySQL。
-   **操作**：修改 `docker-compose.yml`，为 MySQL 服务添加端口映射 `3306:3306`。

### 2. 修复后端 500 错误 (优先级：高)
**目标**：消除因数据格式解析错误导致的服务器崩溃。
-   **操作**：
    -   修改 `server/routes/tables.js` 和 `server/routes/rows.js`。
    -   引入 `safeParse` 辅助函数：如果是字符串则解析，如果是对象则直接使用，从根本上杜绝解析错误。

### 3. 优化登录与认证服务 (优先级：中)
**目标**：解决登录失败问题。
-   **操作**：
    -   检查并确保 `.env` 文件中包含正确的 `OIDC_ISSUER_URL` 和 `OIDC_CLIENT_ID`。
    -   优化 `auth.js` 中的 Cookie 设置，确保在本地 `localhost` 环境下不会因为 `SameSite` 策略被浏览器拦截。

### 4. Docker 部署修复 (优先级：中)
**目标**：确保镜像构建成功且服务可正常启动。
-   **操作**：
    -   检查 `server/Dockerfile` 确保依赖安装完整（已确认包含 Python/Make 编译工具）。
    -   提供 `redeploy.sh` 脚本，自动化执行 "停止旧容器 -> 构建新镜像 -> 启动新容器" 的流程，包含回滚机制。

## 三、 执行步骤

1.  **修改配置**：更新 `docker-compose.yml` 暴露端口。
2.  **代码热修**：应用后端 JSON 解析的防御性代码补丁。
3.  **验证环境**：检查本地 `.env` 配置。
4.  **重启服务**：使用 Docker Compose 重启数据库，并重启本地后端服务。

请确认是否执行此计划？确认后我将开始修改代码和配置文件。
